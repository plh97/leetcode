## [10. Regular Expression Matching](https://leetcode.com/problems/regular-expression-matching/)

###### 2019/02/22

### é¢˜ç›®ğŸ’—
æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…,å¾ˆéš¾ä½†æ˜¯å¿…è€ƒé¢˜,ä¸€å®šè¦ä¼š,é‡‡ç”¨**åŠ¨æ€è§„åˆ’**çš„æ€è·¯ä¹Ÿå°±æ˜¯dp...


> #### æ€è·¯
> é‡‡ç”¨dpæ€æƒ³å»è§£å†³é—®é¢˜


### TODO
- [x] æµ‹è¯•ç”¨ä¾‹é€šè¿‡
- [ ] åŒå±‚forå¾ªç¯éå†ä¸€èˆ¬éƒ½å¾ˆæ…¢,åº”è¯¥å°½é‡é¿å…å†™O(m*n)ä»£ç 
- [ ] äº†è§£ä»€ä¹ˆæ˜¯[åŠ¨æ€è§„åˆ’](../dynamic-programing/README.md)


### æ„Ÿæƒ³
åšäº†è¿™é“é¢˜æˆ‘æ‰çœŸæ­£ç†è§£äº†æ­£åˆ™åŒ¹é…,ä»€ä¹ˆå«åšæ­£åˆ™åŒ¹é…ä¸­çš„**å›æº¯ç®—æ³•**.è¿™æ‰å ªå ªå…¥é—¨ç®—æ³•.æˆ‘æœ‰ç‚¹æ‡‚äº†æ­£åˆ™é‡Œé¢çš„å›æº¯åŒ¹é…äº†.å…¶æ ¸å¿ƒä¸æ­£æ˜¯è¿™ç§åŒ¹é…æ¶ˆè€—ç­–ç•¥å—,å¥½å§,æˆ‘å®Œå…¨é”™è¯¯,è¿™é¢˜åº”è¯¥ç”¨dpæ€æƒ³å»è§£å†³.å¦å¤–ä¹Ÿéå¸¸åæ„Ÿæœ‰äº›è‡ªä»¥ä¸ºæ˜¯çš„äºº,çœ‹åˆ«äººå­¦å¾—æ…¢å°±éª‚äººå®¶æ™ºéšœ.æœ‰äº›ä¸œè¥¿ä¾‹å¦‚åŠ¨æ€è§„åˆ’,ä½ æ²¡å­¦è¿‡æ ¹æœ¬å°±ä¸å¯èƒ½è§£å†³å¾—äº†è¿™ç±»çš„é—®é¢˜,æ ¹æœ¬ä¸æ˜¯æ™ºå•†çš„é—®é¢˜,é™¤éä½ è‡ªå·±èƒ½åˆ›é€ ä¸€ä¸ªåŠ¨æ€è§„åˆ’,è¿™å¯èƒ½å—?å‰äººèŠ±äº†å¤šå°‘å¹´æ‰æ€»ç»“å‡ºåŠ¨æ€è§„åˆ’ç®—æ³•æ€æƒ³?å­¦å¾—æ…¢åªèƒ½è¯´æ˜å­¦ä¹ æ–¹æ³•æœ‰é—®é¢˜,è¿™æ ¹æœ¬ä¸**æ™ºéšœ**æ— å…³.æ²¡æœ‰äººæ˜¯å¯ä»¥å‡­ç©ºåˆ›é€ åŠ¨æ€è§„åˆ’çš„.


### ğŸ˜‚æœ‰å¾…çº æ­£çš„é”™è¯¯
- [ ] è‡ªå·±ä¹±å†™,æ ¹æœ¬å†™ä¸ç²—æ¥...
  çœ‹åˆ°ç½‘ä¸Šå¾ˆå¤šè¯„è®º 
  ```
  easy dp solution, ä¹Ÿå°±æ˜¯è¿™é¢˜åˆ©ç”¨åŠ¨æ€è§„åˆ’çš„æ€æƒ³,å¯ä»¥è§£å†³...
  ```
  è€Œæˆ‘çš„ç­”æ¡ˆ,å‹‰å¼ºé€šè¿‡äº†7/8ä¸ªæµ‹è¯•ç”¨ä¾‹,mmpè¿™å·²ç»éå¸¸å‰å®³äº†å¥½å§,
  ```go
  package isMatch

  import (
    "fmt"
    "strings"
  )

  type description struct {
    val   string
    index int
  }

  // åŒ…æ‹¬`.`æ£€æµ‹ç›®æ ‡å­—ç¬¦ä¸²æ˜¯å¦åŒ¹é…
  func isMatchIncludeDot(s, p string) bool {
    if len(p) > len(s) {
      return false
    }
    for i := range p {
      _p := p[i : i+1]
      if _p != "." && s[i:i+1] != _p {
        return false
      }
    }
    return true
  }

  // å­—ç¬¦ä¸²åŒ¹é…æ¶ˆè€—
  // s: aa -> p: a  åŒ¹é…æ¶ˆè€—ç­–ç•¥: è´ªå©ªåŒ¹é…
  func consume(s, p string) string {
    fmt.Println(s, p)
    if p == "*" {
      return s
    }
    if strings.Index(p, "*") > -1 {
      // æ•´ä¸ªåŒ¹é…æ— æ³•æ¶ˆè€—,å°è¯•åˆ†å‰²åŒ¹é…
      // ppp pp* ä¼˜å…ˆé‡‡ç”¨åˆ†å‰²åŒ¹é…ç­–ç•¥
      // if len(p)>1 && len(s)>len(p)-1 {
      // 	return consume
      // 	// for
      // }
      // æ— é™åŒ¹é…ç­–ç•¥
      ss := s
      for isMatchIncludeDot(ss, p[:len(p)-1]) == true {
        ss = ss[len(p)-1:]
      }
      return ss
    } else {
      if len(s) < len(p) {
        return s
      }
      // å¯¹æ¯”ä¸¤ä¸ªå­—ç¬¦ä¸²æ˜¯å¦ç›¸ç­‰, é‡åˆ° `.` é€šé…ç¬¦
      for i := range p {
        _p := p[i : i+1]
        if _p != "." && s[i:i+1] != _p {
          return s
        }
      }
      return s[len(p):]
    }
  }

  // è¿”å›å½“å‰åŒ¹é…éœ€è¦æ¶ˆé™¤çš„å­—ç¬¦ä¸²
  func getMatch(s string) description {
    // mississippi
    // mis*is*ip*.
    // åŒ¹é…å…³é”®å­—ç¬¦:
    // åŒ¹é…ç­–ç•¥,
    // å­—ç¬¦ä¸²åŒ¹é…ä¸åšæ¶ˆè€—,
    // å­—ç¬¦ä¸²* æ¶ˆè€—ä¸€æ¬¡
    indexStar := strings.Index(s, "*")
    if indexStar == -1 {
      return description{
        val:   s,
        index: len(s),
      }
    }
    // åŒ¹é…å­—ç¬¦ä¸²æ¨¡å¼
    return description{
      // å€¼
      val: s[:indexStar+1],
      // æ¨¡å¼
      index: indexStar + 1,
    }
  }

  func isMatch(s string, p string) bool {
    // é‡‡ç”¨æˆåŠŸåŒ¹é…å°±é”€é¡¹çš„ç­–ç•¥
    //
    for len(p) > 0 && len(s) > 0 {
      description := getMatch(p)
      p = p[description.index:]
      s = consume(s, description.val)

      fmt.Printf("è¦è¢«æ¶ˆè€—çš„å­—ç¬¦ä¸²: %s\t å‰©ä½™å­—ç¬¦ä¸²: %s\n", description.val, p)
      fmt.Println("===========================================================", s)
    }
    fmt.Println("===========================================================")
    return len(s) == 0
  }
  ```
  è‡ªå·±å†™æ ¹æœ¬ä¸å¯èƒ½å†™å‡ºæ¥å•Š, é™¤éæˆ‘åˆ›é€ ä¸€ä¸ªåŠ¨æ€è§„åˆ’,è¿™å¯èƒ½ä¹ˆ??


